#!/usr/bin/env bash

set -euo pipefail

# Needed for `docker manifest`
export DOCKER_CLI_EXPERIMENTAL=enabled
export AWS_PAGER=""

build="${BUILDKITE_BUILD_NUMBER:-0}"
repository="$BUILDKITE_PLUGIN_DYNAMODB_IMAGE_REPOSITORY"
tables=()
script_dir="$(dirname "${BASH_SOURCE[0]}")"

schema_dir="${script_dir}/schemas"

architectures=("arm64" "amd64")

# read a plugin property of type [array, string] into a Bash array. Buildkite
# exposes a string value at BUILDKITE_PLUGIN_{NAME}_{KEY}, and array values at
# BUILDKITE_PLUGIN_{NAME}_{KEY}_{IDX}.
function read_list_property {
  local prefix="BUILDKITE_PLUGIN_DYNAMODB_IMAGE_${1}"
  local property="${prefix}_0"

  result=()

  if [[ -n ${!property:-} ]]; then
    local i=0
    local property="${prefix}_${i}"

    while [[ -n ${!property:-} ]]; do
      result+=("${!property}")

      i=$((i+1))
      property="${prefix}_${i}"
    done
  elif [[ -n ${!prefix:-} ]]; then
    result+=("${!prefix}")
  fi

  [[ ${#result[@]} -gt 0 ]] || return 1
}

function read_tables() {
  if read_list_property 'TABLES'; then
    for table in "${result[@]}"; do
      tables+=("${table}")
    done
  else
    echo "A list of tables must be provided."
  fi
}

function check_null() {
  local variable_name="${1}"

  if [[ -z ${!variable_name} ]]; then
    >&2 echo "${variable_name} is null"
    >&2 echo "stack:" ${FUNCNAME[@]+"${FUNCNAME[@]}"}
    exit 1
  fi
}

# Pull the images for each architecture and start a container with them
function start_containers {
  for architecture in "${architectures[@]}"; do
    docker pull amazon/dynamodb-local --platform linux/$architecture
    docker compose -f $script_dir/docker-compose.yml up --detach --force-recreate amazon-dynamodb-$architecture 
  done
}

# Retrieves schemas and saves them as JSON
function retrieve_schemas { 
  mkdir -p $schema_dir
  for table in "${tables[@]}"; do  
    local schema_file="${schema_dir}/${table}.json"
    echo "Retrieving schema of $table..."
    aws dynamodb describe-table \
      --table-name "${table}" \
      --output json \
      > "${schema_file}"
  done
}

# Create the tables in each image
function create_tables {
  for architecture in "${architectures[@]}"; do
    local dynamo_url=$(docker-compose -f $script_dir/docker-compose.yml port amazon-dynamodb-$architecture 8003)
    echo $dynamo_url
    docker-compose -f $script_dir/docker-compose.yml ps     
    local local_dynamo_endpoint="http://$dynamo_url"
    check_null local_dynamo_endpoint
    echo $local_dynamo_endpoint
    for table in "${tables[@]}"; do
      local schema_file="${schema_dir}/${table}.json"
      local attributes=$(cat "${schema_file}" | jq '.["Table"]."AttributeDefinitions"')
      local key_schema=$(cat "${schema_file}" | jq '.["Table"]."KeySchema"')
      local gsis=$(cat "${schema_file}" | jq '[.["Table"]."GlobalSecondaryIndexes"[] | {Projection: .Projection, IndexName: .IndexName, KeySchema: .KeySchema }]')

      aws dynamodb create-table \
        --table-name "${table}" \
        --attribute-definitions "${attributes}" \
        --key-schema "${key_schema}" \
        --global-secondary-indexes "${gsis}" \
        --billing-mode 'PAY_PER_REQUEST' \
        --region "local" --endpoint ${local_dynamo_endpoint}
    done 

    aws dynamodb list-tables --region "local" --endpoint ${local_dynamo_endpoint}
  done  
}

function publish_images {
  for architecture in "${architectures[@]}"; do
    container_id="$(docker-compose ps -q amazon-dynamodb-$architecture)"
    check_null container_id

    docker commit "${container_id}" "${repository}"

    if [[ ${BUILDKITE_BRANCH:-branch} == "${BUILDKITE_PIPELINE_DEFAULT_BRANCH:-master}" ]]; then
      image="${repository}:${build}-${architecture}"
    else
      image="${repository}:branch-${build}-${architecture}"
    fi

    docker tag "${repository}" "${image}"
    docker push "${image}"
  done
}

function publish_multi_arch_manifest {
  echo "Publishing multi-architecture manifest..."
  if [[ ${BUILDKITE_BRANCH:-branch} == "${BUILDKITE_PIPELINE_DEFAULT_BRANCH:-master}" ]]; then
    image_prefix="${repository}:${build}"

    # Also push this as `latest` on `master`
    docker manifest create -a "${repository}:latest" "${image_prefix}-amd64" "${image_prefix}-arm64"
    docker manifest push "${repository}:latest"
  else
    image_prefix="${repository}:branch-${build}"
  fi

  docker manifest create -a "${image_prefix}" "${image_prefix}-amd64" "${image_prefix}-arm64"
  docker manifest push "${image_prefix}"

  echo "Published image to ECR: $image_prefix"
}

# Initial setup
read_tables
start_containers

# # Create tables
retrieve_schemas
create_tables

# # Publish images
# publish_images
# publish_multi_arch_manifest

docker compose -f $script_dir/docker-compose.yml stop

